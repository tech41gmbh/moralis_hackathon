import { __assign, __awaiter, __generator, __values } from "tslib";
import { toHex } from "@aws-sdk/util-hex-encoding";
export var sendMessageBatchMiddleware = function (options) {
    return function (next) {
        return function (args) { return __awaiter(void 0, void 0, void 0, function () {
            var resp, output, messageIds, entries, _a, _b, entry, _c, _d, entry, md5, hash, _e, _f, e_1_1;
            var e_2, _g, e_1, _h;
            return __generator(this, function (_j) {
                switch (_j.label) {
                    case 0: return [4, next(__assign({}, args))];
                    case 1:
                        resp = _j.sent();
                        output = resp.output;
                        messageIds = [];
                        entries = {};
                        if (output.Successful !== undefined) {
                            try {
                                for (_a = __values(output.Successful), _b = _a.next(); !_b.done; _b = _a.next()) {
                                    entry = _b.value;
                                    if (entry.Id !== undefined) {
                                        entries[entry.Id] = entry;
                                    }
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_b && !_b.done && (_g = _a.return)) _g.call(_a);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                        _j.label = 2;
                    case 2:
                        _j.trys.push([2, 7, 8, 9]);
                        _c = __values(args.input.Entries), _d = _c.next();
                        _j.label = 3;
                    case 3:
                        if (!!_d.done) return [3, 6];
                        entry = _d.value;
                        if (!entries[entry.Id]) return [3, 5];
                        md5 = entries[entry.Id].MD5OfMessageBody;
                        hash = new options.md5();
                        hash.update(entry.MessageBody || "");
                        _e = md5;
                        _f = toHex;
                        return [4, hash.digest()];
                    case 4:
                        if (_e !== _f.apply(void 0, [_j.sent()])) {
                            messageIds.push(entries[entry.Id].MessageId);
                        }
                        _j.label = 5;
                    case 5:
                        _d = _c.next();
                        return [3, 3];
                    case 6: return [3, 9];
                    case 7:
                        e_1_1 = _j.sent();
                        e_1 = { error: e_1_1 };
                        return [3, 9];
                    case 8:
                        try {
                            if (_d && !_d.done && (_h = _c.return)) _h.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7];
                    case 9:
                        if (messageIds.length > 0) {
                            throw new Error("Invalid MD5 checksum on messages: " + messageIds.join(", "));
                        }
                        return [2, resp];
                }
            });
        }); };
    };
};
export var sendMessageBatchMiddlewareOptions = {
    step: "initialize",
    tags: ["VALIDATE_BODY_MD5"],
    name: "sendMessageBatchMiddleware",
    override: true,
};
export var getSendMessageBatchPlugin = function (config) { return ({
    applyToStack: function (clientStack) {
        clientStack.add(sendMessageBatchMiddleware(config), sendMessageBatchMiddlewareOptions);
    },
}); };
